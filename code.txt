%% Test Fault Recovery Mechanism
% This script demonstrates how the fault recovery mechanism works with
% different corruption points.

cd('c:\Users\alexw\Desktop\Safeguarding\code');

% Load robot data
data = load('robot_motion_data_2025-07-21_21-17-35.mat');
robot_data = data.robot_data;

% Create an encryption key (32 bytes)
encryption_key = 'My32ByteSuperSecureKey1234567890!';

% Encrypt data
[encrypted_bytes, iv, hash] = robot_data_encrypt(robot_data, encryption_key);

% Save the encrypted data as raw bytes (without MATLAB format)
fid = fopen('encrypted_data.bin', 'wb');
encrypted_bytes = encrypted_bytes(:); % Make sure it is a column vector
fwrite(fid, length(encrypted_bytes), 'uint32', 'ieee-be'); % input length (big-endian)
fwrite(fid, encrypted_bytes, 'uint8');
fwrite(fid, iv, 'uint8');
fwrite(fid, hash, 'uint8');
fclose(fid);

% Load the raw byte data
fid = fopen('encrypted_data.bin', 'rb');
len = fread(fid, 1, 'uint32=>uint32', 'ieee-be'); % output length (big-endian)
encrypted_bytes = fread(fid, len, 'uint8');
iv = fread(fid, 12, 'uint8');
hash = fread(fid, 32, 'uint8');
fclose(fid);

% Decrypt the data
decrypted_data = robot_data_decrypt(encrypted_bytes, encryption_key, iv, hash);

%% Helper functions for fault recovery
% Function to create checkpoints using SHA-3 hashing
function checkpoints = create_checkpoints(data, interval)
    checkpoints = struct('index', [], 'hash', []);
    
    % Try to use SHA-3, fallback to SHA-256 if not available
    try
        hash_engine = java.security.MessageDigest.getInstance('SHA3-256');
        fprintf('Using SHA-3 for checkpoint hashing\n');
    catch ME
        hash_engine = java.security.MessageDigest.getInstance('SHA-256');
        fprintf('SHA-3 not available (likely due to older Java version), using SHA-256 for checkpoint hashing\n');
        fprintf('Error details: %s\n', ME.message);
    end
    
    % For this example, we'll simulate checkpoint creation every 'interval' data points
    checkpoint_count = 0;
    for i = 1:interval:length(data.time)
        % In a real implementation, this would use SHA-3 hashing
        % Checkpoint = SHA3(AES-CTR(Di) âŠ• GMAC(Di-1))
        
        % Simplified hash calculation for demonstration
        timestamp_bytes = typecast(data.time(i), 'uint8');
        hash_engine.update(timestamp_bytes);
        checkpoint_hash = hash_engine.digest();
        
        % Store checkpoint
        checkpoint_count = checkpoint_count + 1;
        checkpoints(checkpoint_count).index = i;
        checkpoints(checkpoint_count).hash = checkpoint_hash;
    end
    fprintf('Created %d checkpoints\n', checkpoint_count);
end

% Function to find the last valid checkpoint before corruption
function last_valid_index = find_last_valid_checkpoint(~, checkpoints, corruption_index)
    % Find the last checkpoint before the corruption point
    last_valid_index = 1; % Default to first point
    
    for i = 1:length(checkpoints)
        if checkpoints(i).index < corruption_index
            last_valid_index = i; % Store the checkpoint array index
        else
            break;
        end
    end
    fprintf('Last valid checkpoint array index: %d\n', last_valid_index);
    fprintf('Last valid checkpoint data index: %d\n', checkpoints(last_valid_index).index);
end

% Function to recover data from the last valid checkpoint
function [recovered_data, recovery_timestamp] = recover_data(original_data, last_valid_index, checkpoints)
    % In a real implementation, this would rebuild data from cryptographic snapshots
    % For this example, we'll simply restore from the original data
    recovered_data = original_data;
    % Use the actual data index from the checkpoints structure
    data_index = checkpoints(last_valid_index).index;
    recovery_timestamp = original_data.time(data_index);
    fprintf('Data recovered from checkpoint at array index: %d (data index: %d)\n', last_valid_index, data_index);
    fprintf('Recovery timestamp: %f\n', recovery_timestamp);
end

%% Test fault recovery mechanism
fprintf('=== Fault Recovery Test ===\n');

% Create checkpoints every 20 data points for more granular recovery
checkpoints = create_checkpoints(decrypted_data, 20);

% Test with multiple random corruption points to ensure robustness
num_tests = 5;
for test_idx = 1:num_tests
    % Generate random corruption index (avoid first and last few points)
    corruption_index = randi([20, length(decrypted_data.time)-20]);
    
    fprintf('\n--- Test %d: Corruption at index %d ---\n', test_idx, corruption_index);
    [corrupted_data, ~] = simulate_corruption_at_index(decrypted_data, corruption_index);
    last_valid_index = find_last_valid_checkpoint(decrypted_data, checkpoints, corruption_index);
    [recovered_data, recovery_timestamp] = recover_data(decrypted_data, last_valid_index, checkpoints);
    
    % Find the expected recovery point (last checkpoint before corruption)
    expected_checkpoint_idx = 1;
    for i = 1:length(checkpoints)
        if checkpoints(i).index < corruption_index
            expected_checkpoint_idx = i;
        else
            break;
        end
    end
    fprintf('Expected recovery timestamp: %f (from checkpoint at index %d)\n', ...
        decrypted_data.time(checkpoints(expected_checkpoint_idx).index), checkpoints(expected_checkpoint_idx).index);
end

% Also test the original fixed points for consistency
fprintf('\n--- Additional Test: Corruption at index 25 ---\n');
[corrupted_data, corruption_index] = simulate_corruption_at_index(decrypted_data, 25);
last_valid_index = find_last_valid_checkpoint(decrypted_data, checkpoints, corruption_index);
[recovered_data, recovery_timestamp] = recover_data(decrypted_data, last_valid_index, checkpoints);
fprintf('Expected recovery timestamp: %f (from checkpoint at index 1)\n', decrypted_data.time(1));

fprintf('\n--- Additional Test: Corruption at index 75 ---\n');
[corrupted_data, corruption_index] = simulate_corruption_at_index(decrypted_data, 75);
last_valid_index = find_last_valid_checkpoint(decrypted_data, checkpoints, corruption_index);
[recovered_data, recovery_timestamp] = recover_data(decrypted_data, last_valid_index, checkpoints);
fprintf('Expected recovery timestamp: %f (from checkpoint at index %d)\n', decrypted_data.time(61), 61);

%% Helper function to corrupt data at a specific index
function [corrupted_data, corruption_index] = simulate_corruption_at_index(data, index)
    corrupted_data = data;
    corruption_index = index;
    % Corrupt the timestamp at the selected position
    corrupted_data.time(corruption_index) = data.time(corruption_index) + 1e6;
    fprintf('Data corrupted at timestamp index: %d\n', corruption_index);
end

%% Final Test for Encryption Functions
addpath('c:\Users\alexw\Desktop\Safeguarding\code');
cd('c:\Users\alexw\Desktop\Safeguarding\code');

% Load robot data
data = load('robot_motion_data_2025-07-21_21-17-35.mat');
robot_data = data.robot_data;

% Create an encryption key (32 bytes)
encryption_key = 'My32ByteSuperSecureKey1234567890!';

fprintf('Starting final test of encryption/decryption functions...\n');

% Try to encrypt data
try
    [encrypted_bytes, iv, hash] = robot_data_encrypt(robot_data, encryption_key);
    fprintf('Encryption successful!\n');
    fprintf('Encrypted data size: %d bytes\n', length(encrypted_bytes));
    fprintf('IV size: %d bytes\n', length(iv));
    fprintf('Hash size: %d bytes\n', length(hash));
    
    % Try to decrypt data
    decrypted_data = robot_data_decrypt(encrypted_bytes, encryption_key, iv, hash);
    fprintf('Decryption successful!\n');
    fprintf('Original data size: %d\n', length(robot_data.time));
    fprintf('Decrypted data size: %d\n', length(decrypted_data.time));
    
    % Verify data integrity
    if isequal(robot_data.time, decrypted_data.time)
        fprintf('Data integrity verified!\n');
    else
        fprintf('Data integrity check failed!\n');
    end
    
    % Test with different key (should fail)
    fprintf('\nTesting with incorrect key...\n');
    wrong_key = 'Wrong32ByteSuperSecureKey1234567890!';
    try
        robot_data_decrypt(encrypted_bytes, wrong_key, iv, hash);
        fprintf('Decryption with wrong key succeeded (unexpected)!\n');
    catch ME
        fprintf('Decryption with wrong key failed as expected.\n');
        fprintf('Error: %s\n', ME.message);
    end
    
    % Test with corrupted data (should fail)
    fprintf('\nTesting with corrupted data...\n');
    corrupted_data = encrypted_bytes;
    corrupted_data(1) = bitxor(corrupted_data(1), 1); % Flip one bit
    try
        robot_data_decrypt(corrupted_data, encryption_key, iv, hash);
        fprintf('Decryption of corrupted data succeeded (unexpected)!\n');
    catch ME
        fprintf('Decryption of corrupted data failed as expected.\n');
        fprintf('Error: %s\n', ME.message);
    end
    
    fprintf('\nAll tests completed successfully!\n');
    
catch ME
    fprintf('Error occurred:\n');
    fprintf('Message: %s\n', ME.message);
    if ~isempty(ME.stack)
        fprintf('Location: %s at line %d\n', ME.stack(1).name, ME.stack(1).line);
    end
end

fprintf('\nFinal test completed.\n');


Security Module for Robot Motion Data

This module provides encryption, decryption, and fault recovery mechanisms for robot motion data.

Features

1. AES-256-GCM Encryption: Securely encrypts robot motion data with authentication.
2. SHA-256 Verification: Ensures data integrity during decryption.
3. Checkpoint-based Fault Recovery: Implements a recovery mechanism using cryptographic checkpoints.

Implementation Details

Encryption

The data is encrypted using AES-256-GCM mode, which provides both confidentiality and authenticity. A 32-byte encryption key is used along with a 12-byte initialization vector (IV).

Fault Recovery Mechanism

The fault recovery mechanism creates checkpoints at regular intervals (every 50 data points by default) using SHA-3 hashing. If SHA-3 is not available (typically due to an older Java version), it falls back to SHA-256.

When data corruption is detected, the system finds the last valid checkpoint before the corruption point and recovers the data from that point.

SHA-3 Availability

SHA-3 support in Java was added in Java 9. If you're running this code with an older version of Java (Java 8 or earlier), SHA-3 will not be available and the system will automatically fall back to SHA-256. This is normal behavior and does not affect the functionality of the system.

Recovery Process

1. Checkpoints are created at regular intervals during data processing.
2. When data corruption is detected, the system identifies the corruption point.
3. The last valid checkpoint before the corruption point is located.
4. Data is recovered from that checkpoint.

Note that the recovery timestamp corresponds to the timestamp at the checkpoint, not the point immediately before corruption. For example, if data is corrupted at index 50 and checkpoints are created every 50 data points, the last valid checkpoint would be at index 1, and the recovery timestamp would be the timestamp at index 1.

Usage

Run the fault_recovery_test.m script in MATLAB to see the fault recovery mechanism in action.

For batch mode execution, run the run_security.m script which sets the appropriate environment variables.

Testing

Several test scripts are available to verify the functionality:

1. robot_security_test.m - A comprehensive test of encryption and decryption functions including error conditions
2. fault_recovery_test.m - A specialized test of the fault recovery mechanism with detailed checkpoint analysis

All tests should pass successfully, demonstrating that the encryption and decryption functions work correctly and can detect both incorrect keys and corrupted data.

Function Separation

The encryption and decryption functions have been separated into individual files (robot_data_encrypt.m and robot_data_decrypt.m) to ensure proper recognition by MATLAB. Each file contains all necessary helper functions for its operation.
